Index: character.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import math\r\n\r\nimport pygame.image\r\n\r\nfrom SkillBox import SkillBox\r\nfrom sprite_animated import SpriteAnimated\r\nfrom bullet import *\r\nfrom constants import *\r\n\r\nclass Character(pygame.sprite.Sprite):\r\n    def __init__(self, display_image, real_image, x, y, width, height):\r\n        super().__init__()\r\n        self.display_image = pygame.transform.scale(display_image, (width, height))\r\n        self.real_image = pygame.transform.scale(real_image, (width, height))\r\n        self.rect = self.real_image.get_rect(topleft=(x, y))\r\n        self.mask = pygame.mask.from_surface(self.real_image)\r\n        self.face_right = True\r\n        self.shoot_angle = MIN_SHOOT_ANGLE_DISPLAY\r\n        self.speed = 0\r\n        self.on_ground = False\r\n        self.jumping = False\r\n        self.velocity = BASE_VELOCITY\r\n        self.power = 0\r\n        self.teleport = True\r\n        self.freeze = 0\r\n        self.frozen_bullet = True\r\n        self.heal_bullet = True\r\n        self.continuous_bullet = True\r\n        self.shooting = False\r\n        self.HP = 100\r\n        self.max_HP = 100\r\n        self.screen = screen\r\n        self.width = width\r\n        self.height = height\r\n        self.character_animation = SpriteAnimated(screen, \"idle\", 0.1)\r\n        self.turn = False\r\n\r\n        # Khởi tạo các kỹ năng\r\n        tele_img = pygame.image.load(\"image/teleport_skill.jpg\")\r\n        freeze_img = pygame.image.load(\"image/freeze_skill.png\")\r\n        heal_img = pygame.image.load(\"image/healing.jpg\")\r\n        continous_img = pygame.image.load(\"image/continuous_bullet.png\")\r\n\r\n\r\n        skill1 = SkillBox(20, 100, SKILL_BOX_SIZE, SKILL_BOX_SIZE, tele_img, \"Teleport\")\r\n        skill2 = SkillBox(20, 175, SKILL_BOX_SIZE, SKILL_BOX_SIZE, freeze_img, \"Frozen Bullet\")\r\n        skill3 = SkillBox(20, 250, SKILL_BOX_SIZE, SKILL_BOX_SIZE, heal_img, \"Heal Bullet\")\r\n        skill4 = SkillBox(20, 325, SKILL_BOX_SIZE, SKILL_BOX_SIZE, continous_img, \"Continuous Bullet\")\r\n\r\n        self.skills = [skill1, skill2, skill3, skill4]\r\n\r\n    def draw_skills(self, screen, selected_skill):\r\n        \"\"\"Vẽ tất cả kỹ năng của nhân vật.\"\"\"\r\n        for skill in self.skills:\r\n            skill_name = skill.skill_name.lower().replace(\" \", \"_\")\r\n            used = not getattr(self, skill_name, True)  # Chiêu đã dùng nếu trạng thái là False\r\n            selected = skill.skill_name == selected_skill  # Được chọn nếu khớp với selected_skill\r\n            skill.draw(screen, selected=selected, used=used)\r\n\r\n    def angle(self, game_map):\r\n        if not self.on_ground:\r\n            return 0\r\n        for i in range(0, game_map.rect.bottom):\r\n            overlap_pos = self.mask.overlap(game_map.mask,\r\n                                            (game_map.rect.x - self.rect.x, game_map.rect.y - self.rect.y - i))\r\n            if overlap_pos:\r\n                break\r\n        left_y_point = 0\r\n        right_y_point = 0\r\n        for i in range(self.rect.centery, game_map.rect.bottom):\r\n            if game_map.mask.get_at((self.rect.left, i)):\r\n                left_y_point = i\r\n                break\r\n        for i in range(self.rect.centery, game_map.rect.bottom):\r\n            if game_map.mask.get_at((self.rect.right, i)):\r\n                right_y_point = i\r\n                break\r\n        slope = (left_y_point - right_y_point) / (self.rect.left - self.rect.right)\r\n        return -math.atan(slope) * 180 / (math.pi)\r\n\r\n    def draw(self, screen, camera, angle, current_player, moving, shooting, character_angle_line_image, charging, delay_time, freeze_image):\r\n        self.display_image = self.character_animation.image\r\n        flipped_image = pygame.transform.flip(self.display_image, not self.face_right, False)\r\n        rotated_image = pygame.transform.rotate(flipped_image, angle)\r\n        new_rect = rotated_image.get_rect(center=self.rect.center)\r\n\r\n        new_rect.topleft = camera.apply(self).topleft\r\n\r\n        if not moving and current_player == self and not shooting and not self.jumping and delay_time is None:\r\n            rotated_angle = angle + self.shoot_angle if self.face_right else angle - self.shoot_angle\r\n\r\n            rotated_angle_line_image = pygame.transform.rotate(character_angle_line_image, rotated_angle)\r\n            angle_line_rect = rotated_angle_line_image.get_rect(center=self.rect.center)\r\n\r\n            angle_line_rect.center = camera.apply(self).center\r\n\r\n            if (self.face_right and rotated_angle < 90) or (not self.face_right and rotated_angle < -90):\r\n                cover_rect = pygame.Rect(0, 0, rotated_angle_line_image.get_width() // 2,\r\n                                         rotated_angle_line_image.get_height())\r\n            else:\r\n                cover_rect = pygame.Rect(rotated_angle_line_image.get_width() // 2, 0,\r\n                                         rotated_angle_line_image.get_width() // 2,\r\n                                         rotated_angle_line_image.get_height())\r\n\r\n            pygame.draw.rect(rotated_angle_line_image, (0, 0, 0, 0), cover_rect)\r\n            screen.blit(rotated_angle_line_image, angle_line_rect.topleft)\r\n\r\n        if not moving and current_player == self and not shooting and not self.jumping and not self.falling and not charging:\r\n            self.character_animation.state = \"idle\"\r\n        elif moving and current_player == self and not shooting and not self.jumping and not self.falling:\r\n            self.character_animation.state = \"move\"\r\n            self.character_animation.setCenterPos(self.rect.center)\r\n        elif self.jumping and current_player == self and not shooting:\r\n            self.character_animation.state = \"jump\"\r\n            self.character_animation.setCenterPos(self.rect.center)\r\n        elif self.falling and not shooting:\r\n            self.character_animation.state = \"jump\"\r\n            self.character_animation.setCenterPos(self.rect.center)\r\n        elif not self.falling and not moving and not charging and not self.jumping:\r\n            self.character_animation.state = \"idle\"\r\n            self.character_animation.setCenterPos(self.rect.center)\r\n        elif charging and current_player == self:\r\n            self.character_animation.state = \"shooting\"\r\n            self.character_animation.setCenterPos(self.rect.center)\r\n\r\n        screen.blit(rotated_image, new_rect.topleft)\r\n        if self.freeze > 0:\r\n            flipped_freeze_image = pygame.transform.flip(freeze_image, not self.face_right, False)\r\n            rotated_freeze_image = pygame.transform.rotate(flipped_freeze_image, angle)\r\n            freeze_rect = rotated_freeze_image.get_rect(center=new_rect.center)\r\n            screen.blit(rotated_freeze_image, freeze_rect.topleft)\r\n    def move(self, game_map):\r\n        self.rect.x += self.speed\r\n\r\n        if self.rect.x < 1:\r\n            self.rect.x = game_map.rect.left\r\n        if self.rect.left > game_map.rect.right - LIMIT_MOVING_RIGHT:\r\n            self.rect.left = game_map.rect.right - LIMIT_MOVING_RIGHT\r\n\r\n    def update(self, game_map):\r\n        self.character_animation.update()\r\n        self.handle_falling(game_map)\r\n        self.check_on_ground(game_map)\r\n        self.jump(game_map)\r\n\r\n    def handle_falling(self, game_map):\r\n        if not self.jumping and not self.mask.overlap(game_map.mask,\r\n                                                      (game_map.rect.x - self.rect.x, game_map.rect.y - self.rect.y)):\r\n            down = 0\r\n            for i in range(0, int(self.velocity)):\r\n                down = i\r\n                if self.mask.overlap(game_map.mask, (game_map.rect.x - self.rect.x, game_map.rect.y - self.rect.y - i)):\r\n                    break\r\n            self.rect.y += down\r\n            if self.velocity + GRAVITY < MAX_FALL_SPEED:\r\n                self.velocity += GRAVITY\r\n            self.on_ground = False\r\n\r\n    def check_on_ground(self, game_map):\r\n        if self.mask.overlap(game_map.mask, (game_map.rect.x - self.rect.x, game_map.rect.y - self.rect.y)):\r\n            self.velocity = BASE_VELOCITY\r\n            self.on_ground = True\r\n            self.falling = False\r\n        else:\r\n            self.falling = True\r\n\r\n    def jump(self, game_map):\r\n        if self.jumping:\r\n            if self.velocity >= -JUMP_HEIGHT and not self.mask.overlap(\r\n                    game_map.mask, (game_map.rect.x - self.rect.x, game_map.rect.y - self.rect.y + self.velocity)):\r\n                self.rect.y -= self.velocity + 2\r\n                self.velocity -= GRAVITY\r\n            else:\r\n                self.jumping = False\r\n                self.velocity = JUMP_HEIGHT  # Reset vận tốc cho lần nhảy sau\r\n\r\n    def check_collision_with_game_map_y(self, game_map):\r\n        movable = False\r\n        sign = 1 if self.speed > 0 else -1\r\n        self.speed = DEFAULT_CHARACTER_SPEED * sign\r\n        for i in range(1, int(abs(self.speed) + 1)):\r\n            overlap_pos = self.mask.overlap(game_map.mask,\r\n                                            (game_map.rect.x - self.rect.x - i * sign, game_map.rect.y - self.rect.y))\r\n            if overlap_pos == None or self.height - overlap_pos[1] <= HEIGHT_DIFF_ALLOWED:\r\n                movable = True\r\n                speed = i * sign\r\n                if overlap_pos != None:\r\n                    self.rect.y -= (self.height - overlap_pos[1])\r\n        return movable\r\n\r\n    def shoot(self, bullet, game_map):\r\n        angle = self.shoot_angle\r\n        if self.face_right:\r\n            angle += self.angle(game_map)\r\n        else:\r\n            angle += -self.angle(game_map)\r\n\r\n        direction = 1 if self.face_right else -1\r\n\r\n        if isinstance(bullet, ContinuousBullet):\r\n            theta = angle * math.pi / 180\r\n            t = bullet.time\r\n            x0, y0 = self.rect.center\r\n            V = 50\r\n            x0, y0 = (\r\n                self.rect.topleft if not self.face_right else self.rect.topright\r\n            )\r\n            x = x0 + direction * V * math.cos(theta) * t\r\n            y = y0 + -V * math.sin(theta) * t\r\n            bullet.update(x, y)\r\n        else:\r\n            theta = angle * math.pi / 180\r\n            accel = BULLET_ACCEL\r\n            t = bullet.time\r\n            scale = POWER_SCALE\r\n            V = scale * self.power\r\n            x0, y0 = (\r\n                self.rect.topleft if not self.face_right else self.rect.topright\r\n            )\r\n            x = x0 + direction * V * math.cos(theta) * t\r\n            y = y0 + (-V * math.sin(theta) * t + accel * t ** 2 / 2)\r\n            bullet.update(x, y)\r\n\r\n    def check_collision_with_explode_point(self, bullet, explosion_center):\r\n        explosion_mask = pygame.mask.Mask((EXPLODE_RADIUS * 2, EXPLODE_RADIUS * 2), fill=True)\r\n        explosion_rect = explosion_mask.get_rect(center=explosion_center)\r\n\r\n        if self.mask.overlap(explosion_mask, (explosion_rect.x - self.rect.x, explosion_rect.y - self.rect.y)):\r\n            return True\r\n        return False\r\n\r\n    def draw_health_bar(self, camera):\r\n        bar_x = self.rect.centerx - BAR_WIDTH // 2\r\n        bar_y = self.rect.bottom + BAR_OFFSET_Y\r\n\r\n        bar_x, bar_y = camera.apply((bar_x, bar_y))\r\n\r\n        current_health_width = int(BAR_WIDTH * (self.HP / self.max_HP))\r\n\r\n        pygame.draw.rect(screen, HEALTH_BAR_BG_COLOR, (bar_x, bar_y, BAR_WIDTH, BAR_HEIGHT))\r\n        pygame.draw.rect(screen, HEALTH_BAR_COLOR, (bar_x, bar_y, current_health_width, BAR_HEIGHT))\r\n\r\n    def draw_power_bar(self):\r\n        power_ratio = self.power / 100\r\n        power_bar_x = (WINDOW_WIDTH - POWER_BAR_WIDTH) // 2\r\n        power_bar_y = WINDOW_HEIGHT - POWER_BAR_Y_OFFSET\r\n\r\n        pygame.draw.rect(screen, POWER_BAR_BG_COLOR, (power_bar_x, power_bar_y, POWER_BAR_WIDTH, POWER_BAR_HEIGHT))\r\n        pygame.draw.rect(screen, POWER_BAR_COLOR,\r\n                         (power_bar_x, power_bar_y, POWER_BAR_WIDTH * power_ratio, POWER_BAR_HEIGHT))\r\n\r\n        font = pygame.font.Font(None, POWER_BAR_FONT_SIZE)\r\n        for i in range(0, 101, 10):\r\n            x_position = power_bar_x + (i / 100) * POWER_BAR_WIDTH\r\n            text_surface = font.render(str(i), True, BLACK)\r\n            text_rect = text_surface.get_rect(center=(x_position, power_bar_y + POWER_BAR_HEIGHT + 10))\r\n            screen.blit(text_surface, text_rect.topleft)\r\n\r\n    def draw_turn_marker(self,player_name,is_turn, camera):\r\n        if is_turn :\r\n            # Tọa độ của tam giác\r\n            pointer_x = self.rect.centerx\r\n            pointer_y = self.rect.top - 30\r\n\r\n            pointer_x, pointer_y = camera.apply((pointer_x, pointer_y))\r\n\r\n            triangle_points = [\r\n                (pointer_x, pointer_y + 10),\r\n                (pointer_x - 10, pointer_y),\r\n                (pointer_x + 10, pointer_y)\r\n            ]\r\n            pygame.draw.polygon(self.screen, (255, 0, 0), triangle_points)\r\n\r\n\r\n            font = pygame.font.Font(None, 24)  # Font chữ\r\n            text_surface = font.render(player_name, True, (0, 0, 0))  # Màu đen\r\n            text_rect = text_surface.get_rect(center=(pointer_x, pointer_y - 10))\r\n            self.screen.blit(text_surface, text_rect)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/character.py b/character.py
--- a/character.py	(revision d8ff6fc72d929dcbc67b4425a1bdaa57f8d6c6d5)
+++ b/character.py	(date 1732857469023)
@@ -2,7 +2,7 @@
 
 import pygame.image
 
-from SkillBox import SkillBox
+from skill_box import skill_box
 from sprite_animated import SpriteAnimated
 from bullet import *
 from constants import *
@@ -42,10 +42,10 @@
         continous_img = pygame.image.load("image/continuous_bullet.png")
 
 
-        skill1 = SkillBox(20, 100, SKILL_BOX_SIZE, SKILL_BOX_SIZE, tele_img, "Teleport")
-        skill2 = SkillBox(20, 175, SKILL_BOX_SIZE, SKILL_BOX_SIZE, freeze_img, "Frozen Bullet")
-        skill3 = SkillBox(20, 250, SKILL_BOX_SIZE, SKILL_BOX_SIZE, heal_img, "Heal Bullet")
-        skill4 = SkillBox(20, 325, SKILL_BOX_SIZE, SKILL_BOX_SIZE, continous_img, "Continuous Bullet")
+        skill1 = skill_box(20, 100, SKILL_BOX_SIZE, SKILL_BOX_SIZE, tele_img, "Teleport")
+        skill2 = skill_box(20, 175, SKILL_BOX_SIZE, SKILL_BOX_SIZE, freeze_img, "Frozen Bullet")
+        skill3 = skill_box(20, 250, SKILL_BOX_SIZE, SKILL_BOX_SIZE, heal_img, "Heal Bullet")
+        skill4 = skill_box(20, 325, SKILL_BOX_SIZE, SKILL_BOX_SIZE, continous_img, "Continuous Bullet")
 
         self.skills = [skill1, skill2, skill3, skill4]
 
Index: skill_box.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pygame\r\n\r\nfrom constants import RED, ORANGE\r\n\r\n\r\nclass SkillBox:\r\n    def __init__(self, x, y, width, height, skill_image, skill_name):\r\n        self.rect = pygame.Rect(x, y, width, height)\r\n        self.skill_image = skill_image\r\n        self.skill_name = skill_name\r\n        self.is_used = False\r\n\r\n    def draw(self, screen, selected = False,used = False):\r\n        \"\"\"Vẽ kỹ năng lên màn hình với viền đặc biệt nếu được nhấn hoặc sử dụng.\"\"\"\r\n        skill_surface = self.skill_image.copy()\r\n\r\n        # Vẽ hình ảnh kỹ năng\r\n        screen.blit(skill_surface, self.rect.topleft)\r\n\r\n        # Thay đổi màu viền dựa trên trạng thái\r\n        border_color = ORANGE if selected else RED  # Cam nếu được chọn, đỏ nếu không\r\n        pygame.draw.rect(screen, border_color, self.rect, 2)\r\n\r\n        if used:\r\n            pygame.draw.line(screen, RED, self.rect.topleft, self.rect.bottomright, 2)\r\n\r\n    def mark_as_used(self):\r\n        \"\"\"Đánh dấu kỹ năng đã được sử dụng.\"\"\"\r\n        self.is_used = True\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/skill_box.py b/skill_box.py
--- a/skill_box.py	(revision d8ff6fc72d929dcbc67b4425a1bdaa57f8d6c6d5)
+++ b/skill_box.py	(date 1732857469014)
@@ -3,7 +3,7 @@
 from constants import RED, ORANGE
 
 
-class SkillBox:
+class skill_box:
     def __init__(self, x, y, width, height, skill_image, skill_name):
         self.rect = pygame.Rect(x, y, width, height)
         self.skill_image = skill_image
